[{"title":"canvas动画与交互（二）","date":"2017-01-11T13:08:44.000Z","path":"2017/01/11/canvas动画与交互（二）/","text":"第一部分说了写canvas的基础API，这一篇就拿这些API来练习一些简单动画。闲话不多说，这就开始了 匀速直线运动这应该是是最简单的运动了吧。流程在上一篇也讲过了，不停的更新x值，重绘canvas就可以了 代码如下: 直线运动非常简单。不停的改变小球的x值，重绘canvas就可以了。要注意的是，我在绘制小球时，圆心一直在[0, 0]。通过translate来改变小球的位置。在小球到达canvas的右边时，我选择让它从左边重新出现，你也可以让它反弹。 圆周运动在圆周运动中会用到两个新的公式。 1. x = centerX + cos(angle) * radius 2. y = centerY + sin(angle) * radius 其中centerX,centerY表示圆心的位置， angle表示小球与圆心的夹角， radius为圆的半径。根据直角三角形的边角关系：对边 = 斜边 cos（角度）, 临边 = 斜边 sin(角度)。 由于大部分代码和上面重复，这里只写出不同的部分。在线演示123456789101112131415161718192021222324function translation() &#123; var ball = new Ball(20, 0xff0000), centerX = canvas.width / 2, centerY = canvas.height / 2, angle = 0, // 初始角度 vr = 0.01; // 角速度 ball.x = canvas.width / 4; ball.y = canvas.height / 2; var r = canvas.width / 4; //圆周运动的半径 (function drawFrame() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); ball.x = centerX + Math.cos(angle) * r; // Math.cos(angle) * r 获取小球相对于原点在X轴的偏移量 ball.y = centerY + Math.sin(angle) * r; // Math.sin(angle) * r 获取小球相对于原点在Y轴的偏移量 angle += vr; ball.draw(ctx); window.requestAnimationFrame(drawFrame); &#125;)();&#125; 相对于直线运动，圆周运动多了y轴的变化。观察一下圆周运动, 会发现一些规律：121. 当X轴速度最大时，Y轴速度最小2. 相对于中心点，圆周运动在X轴与Y轴的振幅相同 如果想要做一个椭圆运动呢？你知道怎么做了吧… 公式小结12345671. 直线运动 ball.x += ball.vx; ball.y += ball.vy;2. 圆周运动 ball.x = centerX + cos(angle) * r; ball.y = centerY + sin(angle) * r; 结语第二部分讲了两个简单动画，下部分会加入加速度和旋转的概念。","tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas动画与交互（一）","date":"2017-01-10T12:10:32.000Z","path":"2017/01/10/canvas动画与交互（一）/","text":"从学习前端开始就一直对canvas很感兴趣，特别羡慕那些使用canvas制作各种动画和游戏的大神们。但是由于各种各样的原因，一直没有去研究。前段时间公司采购书籍，我就报了一本《HTML5+javascript动画基础》，正好最近手头任务不多，就拿出来学习一二。我会将学习与思考的一些内容分几部分写出来，算是做个记录和备忘吧。 今天是第一部分 《canvas基础》 获取绘图环境一开始当然是获取canvas绘图环境 12var canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'); canvas是canvas元素，而ctx就是我们之后的绘图环境上下文了。这里有个地方要注意的是在设置canvas宽度和高的时候，一定要用canvas的width和height属性，而不能用css设置宽高，不然画出的图像大小会有bug 基础API叫API可能不太准确，在这里会列出比较常用的属性和方法 属性12345ctx.fillStyle //填充的样式，允许的值为颜色，渐变或者模式ctx.strokeStyle //描边的样式，允许的值同fillStylectx.lineWidth //线条宽度ctx.globalAlpha //透明度ctx.globalCompositeOperation //合成方式 以PS为例 - fillStyle可以理解为油漆桶的样式，可以是纯颜色或者渐变，在这里还有模式 - strokeStyle可以理解为笔刷的样式 - globalCompositeOperation可以理解为图层的混合模式，表示图层见的合成方法 方法12345678910111213ctx.createLinearGradient() //创建线性渐变ctx.createRadialGradient() //创建径向渐变ctx.beginPath() //开始一个路径ctx.closePath() //闭合一个路径ctx.fillRect() //填充一个矩形ctx.strokeRect() //描边一个矩形ctx.clearRect() //清楚一个矩形ctx.moveTo() //移动到指定的位置，不产生路径ctx.lineTo() //移动到指定的位置，产生路径ctx.arc() //绘制一个圆或圆弧的路径ctx.fill() //填充现有路径ctx.stroke() //描边现有路径ctx.drawImage() //绘制一张图片 以上方法中所有绘制路径的方法都不会立刻在画布上绘制图形，直到调用fill或者stroke方法。moveTo与lineTo的区别在于是否产生路径，lineTo像是在纸上话一条线，而moveTo像是提起笔移动到一个位置。clearRect常被用来清除画布，ctx.clearRect(0, 0, canvas.width, canvas.height)。另一种方法是重新设置canvas.widht。 动画既然是动画，那当然需要动起来。那个最简单的例子来说，一个小球重屏幕的左边移动到屏幕的右边，代码的流程应该是： 1. 在画布左边绘制一个小球 2. 清除原来的小球，在往右边几个像素绘制一个新的小球 反复循环第二步，直到小球到达屏幕的右边，伪代码如下： 12345678创建小球设置小球位置在画布上绘制小球循环 设置小球的新位置 清空画布 在画布上绘制新的小球结束循环 简单说canvas动画的本质就是不停的清空画布，然后重绘。 结语第一部分就到这里结束吧。都还是一些理论基础，下部分会讲几个简单的动画","tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"Hello World","date":"2017-01-09T12:50:09.188Z","path":"2017/01/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]